// DataPacker.h

#ifndef _DATAPACKER_h
#define _DATAPACKER_h

#if defined(ARDUINO) && ARDUINO >= 100
#include "arduino.h"
#else
#include "WProgram.h"
#endif

#define SIZE_DOUBLE sizeof(double)
#define SIZE_FLOAT sizeof(float)
#define SIZE_UINT64 sizeof(uint64_t)
#define SIZE_INT64 sizeof(int64_t)
#define SIZE_UINT32 sizeof(uint32_t)
#define SIZE_INT32 sizeof(int32_t)
#define SIZE_UINT16 sizeof(uint16_t)
#define SIZE_INT16 sizeof(int16_t)
#define SIZE_UINT8 sizeof(uint8_t)
#define SIZE_INT8 sizeof(int8_t)
#define SIZE_UCHAR sizeof(unsigned char)
#define SIZE_CHAR sizeof(char)
#define SIZE_BYTE sizeof(byte)
#define SIZE_BOOL sizeof(bool)

typedef uint8_t SizeMap_t;

#define USE_CRC32       false
#define USE_CRC16       true
#define USE_CRC8        false
#define USE_CHECKSUM    false
#define USE_DUMPER		true

#if (USE_CRC8 == true)
#define CHECKSUM_LENGTH 1
#endif
#if (USE_CHECKSUM == true)
#define CHECKSUM_LENGTH 2
#endif
#if (USE_CRC16 == true)
#define CHECKSUM_LENGTH 2
#endif
#if (USE_CRC32 == true)
#define CHECKSUM_LENGTH 4
#endif
#if (USE_CHECKSUM == 0 && USE_CRC32 == 0 && USE_CRC16 == 0 && USE_CRC8 == 0)
#define CHECKSUM_LENGTH 0
#endif

#define SplitBytes(destBuffer, offset, value, size) if(destBuffer){uint8_t * __splitbytes__buffer__; __splitbytes__buffer__ = ((uint8_t *)value);  memcpy(destBuffer + offset, __splitbytes__buffer__, size);}
#define MergeBytes(type, srcBuffer, offset) ((type)&srcBuffer[offset])

#if (USE_CRC32 == true)
static const uint32_t CRC32Table[256] = {
	0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
	0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
	0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
	0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
	0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
	0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
	0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
	0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
	0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
	0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
	0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
	0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
	0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
	0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
	0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
	0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,

	0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
	0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
	0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
	0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
	0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
	0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
	0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
	0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
	0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
	0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
	0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
	0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
	0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
	0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
	0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
	0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,

	0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
	0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
	0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
	0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
	0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
	0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
	0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
	0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
	0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
	0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
	0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
	0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
	0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
	0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
	0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
	0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,

	0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
	0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
	0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
	0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
	0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
	0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
	0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
	0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
	0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
	0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
	0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
	0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
	0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
	0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
	0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
	0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};
#endif
#if (USE_CRC16 == true)
static const uint16_t CRC16Table[256] = {
	0x0000, 0x1189, 0x2312, 0x329B, 0x4624, 0x57AD, 0x6536, 0x74BF,
	0x8C48, 0x9DC1, 0xAF5A, 0xBED3, 0xCA6C, 0xDBE5, 0xE97E, 0xF8F7,
	0x0919, 0x1890, 0x2A0B, 0x3B82, 0x4F3D, 0x5EB4, 0x6C2F, 0x7DA6,
	0x8551, 0x94D8, 0xA643, 0xB7CA, 0xC375, 0xD2FC, 0xE067, 0xF1EE,
	0x1232, 0x03BB, 0x3120, 0x20A9, 0x5416, 0x459F, 0x7704, 0x668D,
	0x9E7A, 0x8FF3, 0xBD68, 0xACE1, 0xD85E, 0xC9D7, 0xFB4C, 0xEAC5,
	0x1B2B, 0x0AA2, 0x3839, 0x29B0, 0x5D0F, 0x4C86, 0x7E1D, 0x6F94,
	0x9763, 0x86EA, 0xB471, 0xA5F8, 0xD147, 0xC0CE, 0xF255, 0xE3DC,
	0x2464, 0x35ED, 0x0776, 0x16FF, 0x6240, 0x73C9, 0x4152, 0x50DB,
	0xA82C, 0xB9A5, 0x8B3E, 0x9AB7, 0xEE08, 0xFF81, 0xCD1A, 0xDC93,
	0x2D7D, 0x3CF4, 0x0E6F, 0x1FE6, 0x6B59, 0x7AD0, 0x484B, 0x59C2,
	0xA135, 0xB0BC, 0x8227, 0x93AE, 0xE711, 0xF698, 0xC403, 0xD58A,
	0x3656, 0x27DF, 0x1544, 0x04CD, 0x7072, 0x61FB, 0x5360, 0x42E9,
	0xBA1E, 0xAB97, 0x990C, 0x8885, 0xFC3A, 0xEDB3, 0xDF28, 0xCEA1,
	0x3F4F, 0x2EC6, 0x1C5D, 0x0DD4, 0x796B, 0x68E2, 0x5A79, 0x4BF0,
	0xB307, 0xA28E, 0x9015, 0x819C, 0xF523, 0xE4AA, 0xD631, 0xC7B8,
	0x48C8, 0x5941, 0x6BDA, 0x7A53, 0x0EEC, 0x1F65, 0x2DFE, 0x3C77,
	0xC480, 0xD509, 0xE792, 0xF61B, 0x82A4, 0x932D, 0xA1B6, 0xB03F,
	0x41D1, 0x5058, 0x62C3, 0x734A, 0x07F5, 0x167C, 0x24E7, 0x356E,
	0xCD99, 0xDC10, 0xEE8B, 0xFF02, 0x8BBD, 0x9A34, 0xA8AF, 0xB926,
	0x5AFA, 0x4B73, 0x79E8, 0x6861, 0x1CDE, 0x0D57, 0x3FCC, 0x2E45,
	0xD6B2, 0xC73B, 0xF5A0, 0xE429, 0x9096, 0x811F, 0xB384, 0xA20D,
	0x53E3, 0x426A, 0x70F1, 0x6178, 0x15C7, 0x044E, 0x36D5, 0x275C,
	0xDFAB, 0xCE22, 0xFCB9, 0xED30, 0x998F, 0x8806, 0xBA9D, 0xAB14,
	0x6CAC, 0x7D25, 0x4FBE, 0x5E37, 0x2A88, 0x3B01, 0x099A, 0x1813,
	0xE0E4, 0xF16D, 0xC3F6, 0xD27F, 0xA6C0, 0xB749, 0x85D2, 0x945B,
	0x65B5, 0x743C, 0x46A7, 0x572E, 0x2391, 0x3218, 0x0083, 0x110A,
	0xE9FD, 0xF874, 0xCAEF, 0xDB66, 0xAFD9, 0xBE50, 0x8CCB, 0x9D42,
	0x7E9E, 0x6F17, 0x5D8C, 0x4C05, 0x38BA, 0x2933, 0x1BA8, 0x0A21,
	0xF2D6, 0xE35F, 0xD1C4, 0xC04D, 0xB4F2, 0xA57B, 0x97E0, 0x8669,
	0x7787, 0x660E, 0x5495, 0x451C, 0x31A3, 0x202A, 0x12B1, 0x0338,
	0xFBCF, 0xEA46, 0xD8DD, 0xC954, 0xBDEB, 0xAC62, 0x9EF9, 0x8F70 };
#endif
#if (USE_CRC8 == true)
static const uint8_t CRC8Table[256] = {
	0x00,0x91,0xE3,0x72,0x07,0x96,0xE4,0x75,0x0E,0x9F,0xED,0x7C,0x09,0x98,0xEA,0x7B,
	0x1C,0x8D,0xFF,0x6E,0x1B,0x8A,0xF8,0x69,0x12,0x83,0xF1,0x60,0x15,0x84,0xF6,0x67,
	0x38,0xA9,0xDB,0x4A,0x3F,0xAE,0xDC,0x4D,0x36,0xA7,0xD5,0x44,0x31,0xA0,0xD2,0x43,
	0x24,0xB5,0xC7,0x56,0x23,0xB2,0xC0,0x51,0x2A,0xBB,0xC9,0x58,0x2D,0xBC,0xCE,0x5F,
	0x70,0xE1,0x93,0x02,0x77,0xE6,0x94,0x05,0x7E,0xEF,0x9D,0x0C,0x79,0xE8,0x9A,0x0B,
	0x6C,0xFD,0x8F,0x1E,0x6B,0xFA,0x88,0x19,0x62,0xF3,0x81,0x10,0x65,0xF4,0x86,0x17,
	0x48,0xD9,0xAB,0x3A,0x4F,0xDE,0xAC,0x3D,0x46,0xD7,0xA5,0x34,0x41,0xD0,0xA2,0x33,
	0x54,0xC5,0xB7,0x26,0x53,0xC2,0xB0,0x21,0x5A,0xCB,0xB9,0x28,0x5D,0xCC,0xBE,0x2F,
	0xE0,0x71,0x03,0x92,0xE7,0x76,0x04,0x95,0xEE,0x7F,0x0D,0x9C,0xE9,0x78,0x0A,0x9B,
	0xFC,0x6D,0x1F,0x8E,0xFB,0x6A,0x18,0x89,0xF2,0x63,0x11,0x80,0xF5,0x64,0x16,0x87,
	0xD8,0x49,0x3B,0xAA,0xDF,0x4E,0x3C,0xAD,0xD6,0x47,0x35,0xA4,0xD1,0x40,0x32,0xA3,
	0xC4,0x55,0x27,0xB6,0xC3,0x52,0x20,0xB1,0xCA,0x5B,0x29,0xB8,0xCD,0x5C,0x2E,0xBF,
	0x90,0x01,0x73,0xE2,0x97,0x06,0x74,0xE5,0x9E,0x0F,0x7D,0xEC,0x99,0x08,0x7A,0xEB,
	0x8C,0x1D,0x6F,0xFE,0x8B,0x1A,0x68,0xF9,0x82,0x13,0x61,0xF0,0x85,0x14,0x66,0xF7,
	0xA8,0x39,0x4B,0xDA,0xAF,0x3E,0x4C,0xDD,0xA6,0x37,0x45,0xD4,0xA1,0x30,0x42,0xD3,
	0xB4,0x25,0x57,0xC6,0xB3,0x22,0x50,0xC1,0xBA,0x2B,0x59,0xC8,0xBD,0x2C,0x5E,0xCF
};
#endif


char toHex(uint8_t val) {
	if (val > 0x0F)
		return '?';
	static const char * hexChar = "0123456789ABCDEF";
	return hexChar[val];
}

//the size included 2 byte checksum (or 4 byte with CRC32, 2 with CRC16, 1 with CRC8)
template <uint8_t size>
class DataPacker {
private:
	//actual data
	uint8_t bytes[size];
	//map of indexes, removed to reduce RAM usage
	//uint8_t indexMap[size];
	//map of member sizes
	uint8_t sizeMap[size] = {};
	//number of members
	uint8_t memberCount = 0;
	//current index of array
	uint8_t pointerIndex = 0;
#if (USE_DUMPER == true)
	//used for DumpBuffer
	//3 char each byte, 2 begin char, 1 end char, 1 null char
	char textBuffer[size * 3 + 4];
#endif

public:
	DataPacker() {
		Clear();
	}

	void Clone(uint8_t * src, uint8_t srcOffset = 0, uint8_t len = size) {
		Clear();
		if (len > size)
			len = size;
		memcpy(bytes, src + srcOffset, len);
	}

	void SetSizeMap(uint8_t numberOfMember, const uint8_t * newMap) {
		memset(sizeMap, 0, size);
		for (uint8_t i = 0; i < numberOfMember; i++) {
			sizeMap[i] = newMap[i];
		}
		memberCount = numberOfMember;
	}

	void Clear() {
		memset(bytes, 0, sizeof(bytes));
		//memset(indexMap, 0, sizeof(indexMap));
		memset(sizeMap, 0, sizeof(sizeMap));
		memberCount = 0;
		pointerIndex = 0;
	}

	uint8_t * GetBuffer() {
		return bytes;
	}

	uint8_t Size() {
		return size;
	}

#if (USE_CHECKSUM == true)
	//calculate Checksum then add to buffer
	void AddChecksum() {
		uint16_t sum = CalcChecksum();
		SplitBytes(bytes, size - CHECKSUM_LENGTH, &sum, CHECKSUM_LENGTH);
	}
	//calculate Checksum from buffer
	uint16_t CalcChecksum() {
		uint16_t sum = 0;
		for (uint8_t i = 0; i < size - CHECKSUM_LENGTH; i++) {
			sum += (uint8_t)bytes[i];
		}
		return sum;
	}
	//get Checksum saved in buffer
	uint16_t GetChecksum() {
		return *MergeBytes(uint16_t*, bytes, size - CHECKSUM_LENGTH);
	}
	bool Checksum() {
		return CalcChecksum() == GetChecksum();
	}
#endif
#if (USE_CRC32 == true)
	//calculate CRC then add to buffer
	void AddCRC32() {
		uint16_t crc = CalcCRC32();
		SplitBytes(bytes, size - CHECKSUM_LENGTH, &crc, CHECKSUM_LENGTH);
	}
	//calculate CRC from buffer
	uint16_t CalcCRC32() {
		uint32_t crc = 0xFFFFFFFF;
		for (uint8_t i = 0; i < size - CHECKSUM_LENGTH; i++) {
			uint8_t nLockupIndex = (crc ^ bytes[i]) & 0xFF;
			crc = (crc << 8) ^ CRC32Table[nLockupIndex];
		}
		crc ^= 0xFFFFFFFF;

		return crc;
	}
	//get CRC saved in buffer
	uint16_t GetCRC32() {
		return MergeBytes(uint16_t, bytes, size - CHECKSUM_LENGTH);
	}
	bool CheckCRC32() {
		return CalcCRC32() == GetCRC32();
	}
#endif
#if (USE_CRC16 == true)
	//calculate CRC then add to buffer
	void AddCRC16() {
		uint16_t crc = CalcCRC16();
		SplitBytes(bytes, size - CHECKSUM_LENGTH, &crc, CHECKSUM_LENGTH);
	}
	//calculate CRC from buffer
	uint16_t CalcCRC16() {
		uint16_t crc = 0xFFFF;
		for (uint8_t i = 0; i < size - CHECKSUM_LENGTH; i++) {
			uint8_t nLockupIndex = (crc >> 8) ^ bytes[i];
			crc = (crc << 8) ^ CRC16Table[nLockupIndex];
		}
		crc ^= 0xFFFF;

		return crc;
	}
	//get CRC saved in buffer
	uint16_t GetCRC16() {
		return *MergeBytes(uint16_t*, bytes, size - CHECKSUM_LENGTH);
	}
	bool CheckCRC16() {
		return CalcCRC16() == GetCRC16();
	}
#endif
#if (USE_CRC8 == true)
	void AddCRC8() {
		uint16_t crc = CalcCRC8();
		bytes[size - CHECKSUM_LENGTH] = crc;
	}
	//calculate CRC from buffer
	uint16_t CalcCRC8() {
		uint8_t crc = 0x00;
		for (uint8_t i = 0; i < size - CHECKSUM_LENGTH; i++) {
			uint8_t nLockupIndex = crc ^ bytes[i];
			crc = CRC8Table[nLockupIndex];
		}
		crc ^= 0xFF;
		return crc;
	}
	//get CRC saved in buffer
	uint16_t GetCRC8() {
		return *MergeBytes(uint16_t*, bytes, size - CHECKSUM_LENGTH);
	}
	bool CheckCRC8() {
		return CalcCRC8() == GetCRC8();
	}
#endif

	template <typename T>
	int8_t AddNumber(T value) {
		if (pointerIndex + sizeof(T) + CHECKSUM_LENGTH > size)
			return -1;
		SplitBytes(bytes, pointerIndex, &value, sizeof(T));

		//indexMap[memberCount] = pointerIndex;
		sizeMap[memberCount] = sizeof(T);

		memberCount++;
		pointerIndex += sizeof(T);

		return pointerIndex - sizeof(T);
	}

	/*template <typename T, uint8_t sizeOfType>
	int8_t AddString(T value) {
		if (pointerIndex + sizeOfType + 2 > size)
			return -1;
		SplitBytes(bytes, pointerIndex, value, sizeOfType);

		//indexMap[memberCount] = pointerIndex;
		sizeMap[memberCount] = sizeOfType;

		memberCount++;
		pointerIndex += sizeOfType;

		return pointerIndex - sizeOfType;
	}*/
	int8_t AddString(const char * value) {
		if (pointerIndex + (strlen(value) + 1) + CHECKSUM_LENGTH > size)
			return -1;
		SplitBytes(bytes, pointerIndex, value, strlen(value) + 1);

		//indexMap[memberCount] = pointerIndex;
		sizeMap[memberCount] = (strlen(value) + 1);

		memberCount++;
		pointerIndex += (strlen(value) + 1);

		return pointerIndex - (strlen(value) + 1);
	}

	template <typename T>
	T GetNumber(uint8_t index) {
		uint8_t arrayOffset = 0;
		for (uint8_t i = 0; i < index; i++)
			arrayOffset += sizeMap[i];

		return *MergeBytes(T*, bytes, arrayOffset);
	}

	/*template <typename T>
	T GetString(uint8_t index) {
		uint8_t arrayOffset = 0;
		for (uint8_t i = 0; i < index; i++)
			arrayOffset += sizeMap[i];

		return MergeBytes(T, bytes, arrayOffset);
	}*/

	const char * GetString(uint8_t index) {
		uint8_t arrayOffset = 0;
		for (uint8_t i = 0; i < index; i++)
			arrayOffset += sizeMap[i];

		return MergeBytes(const char *, bytes, arrayOffset);
	}
#if (USE_DUMPER == true)
	char * DumpBuffer() {
		uint16_t currentIndex = 0;
		textBuffer[currentIndex++] = '[';
		textBuffer[currentIndex++] = ' ';

		for (int i = 0; i < size; i++) {
			//Bluetooth.print("byte: ");
			//Bluetooth.println(bytes[i]);
			if (bytes[i] < 0x10) {
				textBuffer[currentIndex++] = '0';
				textBuffer[currentIndex++] = toHex(bytes[i]);//to ascii
			}
			else {
				textBuffer[currentIndex++] = toHex(bytes[i] >> 4);
				textBuffer[currentIndex++] = toHex(bytes[i] & 0x0F);//to ascii
			}
			//output += bytes[i].ToString();
			textBuffer[currentIndex++] = ' ';
			//Serial.println(currentIndex);
		}
		textBuffer[currentIndex++] = ']';
		return textBuffer;
	}
#endif
};
#endif
